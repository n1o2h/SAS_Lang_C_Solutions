Hello @Classe 1  Merci de Faire une recherche sur les aspects
Q1: J'ai vu la conversion %i utilisée pour lire et écrire des entiers. Quelle est la différence entre %i et %d ?
Q2: Si printf traite % comme le début d'une spécification de conversion, comment puis-je imprimer le caractère % ?
Q3: La séquence d'échappement \t est censée faire avancer printf jusqu'au prochain taquet de tabulation. Comment puis-je savoir à quelle distance se trouvent les taquets de tabulation ?
Q4: Que fait scanf s'il lui est demandé de lire un nombre mais que l'utilisateur entre une entrée non numérique ?
Q5: Je ne comprends pas comment scanf peut "remettre" des caractères et les relire plus tard.
Q6: Que fait scanf si l'utilisateur met des signes de ponctuation (des virgules, par exemple) entre les nombres ?
Q7: Je veux appliquer l'opérateur % à un opérande à virgule flottante, mais mon programme ne compile pas. Que puis-je faire ?
Q8: Pourquoi les règles d'utilisation des opérateurs / et % avec des opérandes négatifs sont-elles si compliquées ?
Q9: Si C a des lvalues, a-t-il aussi des rvalues ?
Q10: Vous avez dit que v += e n'est pas équivalent à v = v + e si v a un effet de bord. Pouvez-vous expliquer ?
Q11: Pourquoi C fournit-il les opérateurs ++ et -- ? Sont-ils plus rapides que d'autres moyens d'incrémenter et de décrémenter, ou sont-ils simplement plus pratiques ?
Q12: Les opérateurs ++ et -- fonctionnent-ils avec des variables de type float ?
Q13: Lorsque j'utilise la version post-fixe de ++ ou --, quand exactement l'incrémentation ou la décrémentation est-elle effectuée ?
Q14: Mon compilateur n'affiche pas d'avertissement lorsque j'utilise = au lieu de ==. Y a-t-il un moyen de forcer le compilateur à remarquer le problème ?
Q15: Si i est une variable de type int et f est une variable de type float, quel est le type de l'expression conditionnelle (i > 0 ? i : f) ?
Q16: Le modèle donné pour l'instruction switch le décrivait comme la "forme la plus courante". Existe-t-il d'autres formes ?
Q17: J'ai vu plusieurs méthodes pour indenter l'instruction switch. Laquelle est la meilleure ?
Q18: Quelle forme de boucle infinie est préférable, while (1) ou for (;;) ?
Q19: J'ai entendu dire que les programmeurs ne devraient jamais utiliser l'instruction continue. Est-ce vrai ?
Q20: Qu'est-ce qui est si mauvais avec l'instruction goto ?
Q21: L'instruction nulle a-t-elle d'autres usages que d'indiquer que le corps d'une boucle est vide ?
Q22: Y a-t-il d'autres moyens de faire ressortir le corps de boucle vide que de placer l'instruction nulle sur une ligne à part ?
Q23: %o et %x sont utilisés pour écrire des entiers non signés en notation octale et hexadécimale. Comment puis-je écrire des entiers ordinaires (signés) en octal ou en hexadécimal ?
Q24: Mais que se passe-t-il si le nombre est négatif ? Comment puis-je l'écrire en octal ou en hexadécimal ?
Q25: Pourquoi les constantes à virgule flottante sont-elles stockées sous la forme double plutôt que float ?
Q26: À quoi ressemblent les constantes hexadécimales à virgule flottante et à quoi servent-elles ?
Q27: Pourquoi utilisons-nous %lf pour lire une valeur double mais %f pour l'imprimer ?
Q28: Quelle est la bonne façon de prononcer char ?
Q29: Quand est-ce que cela a de l'importance si une variable de type char est signée ou non signée ?
Q30: Je ne comprends pas comment le caractère de nouvelle ligne peut être le caractère ASCII de saut de ligne. Quand un utilisateur saisit une entrée et appuie sur la touche Entrée, le programme ne lit-il pas cela comme un caractère de retour chariot ou un retour chariot plus un saut de ligne ?
Q31: Si getchar est plus rapide, pourquoi voudrions-nous utiliser scanf pour lire des caractères individuels ?
Q32: Dans quelles circonstances les promotions intégrales convertissent-elles un caractère ou un entier court en unsigned int ?
Q33: Que se passe-t-il exactement si j'affecte une valeur à une variable qui n'est pas assez grande pour la contenir ?
Q34: Pourquoi C se donne-t-il la peine de fournir des définitions de type ? Est-ce que définir une macro BOOL n'est pas aussi bien que de définir un type Bool en utilisant typedef ?
Q35: Vous avez dit que les compilateurs "peuvent généralement déterminer la valeur d'une expression sizeof." Un compilateur ne peut-il pas toujours déterminer la valeur d'une expression sizeof ?